//データフォーマット定義JSONサンプル
{
	"version": "1.0",	//データバージョン　※構造一致照合用
	"name": "CharaData",	//データ名　※構造一致照合用
	"sourceFileName": "charaData.h",	//ソースファイル名　※C言語ソースヘッダーファイル出力用
	
	"struct":	//構造体
	{
		"name": "T_CHARA",		//構造体名
		"comment": "キャラ構造体",	//コメント　※C言語ソース用
		
		"isMakeSource": true,		//構造体の定義をC言語ヘッダーに出力するか？
							//　※規定値は true。汎用構造体などの定義済みの構造体を用いる場合は
							//　　 false を指定する。
		
		"primaryKey": "id",		//主キー項目　※メンバー名で指定。主キー順にデータが並べ替えされる。
							//　　　　　　　重複検出でエラー。ネストした構造体のメンバーは指定不可。
		"secondaryKey": "name",	//副キー項目　※メンバー名で指定。検索用のインデックステーブルが作成される。
							//　　　　　　　重複検出でエラー。ネストした構造体のメンバーは指定不可。
		
		"indexes": ["kana"],		//インデックス項目　※キーで指定。並べ替え用のインデックステーブル作成用。
							//　　　　　　　　　　複数キー指定可。複合キー指定不可。重複検出なし。
							//　　　　　　　　　　ネストした構造体のメンバーは指定不可。
		
		"members":				//メンバー　※デフォルトでは、定義順がデータの並び順になるので注意。
		[
			//メンバー定義:基本形
			{
				"name": "id",			//メンバー名
				"comment": "識別ID",	//コメント　※C言語ソース用。
				"key": "id",			//対象キー　※JSONデータ上のキー。
									//　　　　　　省略時は "name" と同じとみなす。
				"type": "u32",			//データ型　※s8,u8,s16,u16,s32,u32,s64,u64,f31,f64,ptr,struct,
									//　　　　　　str,expr,crc,crcs を指定可。
									//　　　　　　crc,crcs は文字列が32bit整数に変換される。
									//　　　　　　expr は文字列が計算式データに変換される。
									//　　　　　　str と expr はポインターに変換され。
									//　　　　　　バイナリデータにはオフセット値として記録される。
				"typeName": "CRC"		//データ型名　※C言語ソース用
									//　　　　　　　特別に指定したい場合だけ指定。
									//　　　　　　　通常は "type" に対応した型から自動判定される。
			},
			//メンバー定義:文字列型の場合
			{
				"name": "name",		//メンバー名
				"comment": "名前",		//コメント
				"type": "str"			//データ型　※文字列のデータ型は、C言語ソース上では
									//　　　　　　 const char* などのポインター型に置き換わる。
									//　　　　　　文字列データはバイナリデータの後部にまとめられ、
									//　　　　　　ポインターはその位置を指す。
									//　　　　　　バイナリデータ上では、文字列データのオフセット値が
									//　　　　　　記録される。
			},
			//メンバー定義:計算式型の場合
			{
				"name": "condition",		//メンバー名
				"comment": "有効化条件式",//コメント
				"type": "expr"		//データ型　※計算式のデータ型は、C言語ソース上では
									//　　　　　　 const T_EXPR* 型に置き換わる。
									//　　　　　　実際のデータはバイナリデータの後部にまとめられ、
									//　　　　　　ポインターはその位置を指す。
									//　　　　　　バイナリデータ上では、計算式データのオフセット値が
									//　　　　　　記録される。
									//　　　　　※JSONデータに記述された計算式（文字列）を解析して、
									//　　　　　　計算式データ（バイナリ）に変換して記録する。
									//　　　　　　この解析の際にエラー判定も行う。
									//　　　　　※計算式内で使用される関数は、実機側の処理で
									//　　　　　　計算式用に用意された関数を指定できる。
									//　　　　　　正しい名前とパラメータで関数を使用しているか
									//　　　　　　どうかは、変換ツール実行時に渡される
									//　　　　　　「関数定義リスト」に基づいて判定する。
			},
			//メンバー定義:値の場合　※エラー判定のサンプル
			{
				"name": "power",		//メンバー名
				"comment": "力",		//コメント
				"key": "param.power",	//対象キー　※JSONデータ上のネストしたデータは
									//　　　　　　「.」で区切って指定。
				"type": "i8",			//データ型
				"default": 1,			//省略時の規定値　※JSONデータ上で記述されなかった場合の規定値。
				"isRequired": false,		//入力必須項目？　※JSONデータ上で記述が必須か？
									//　　　　　　　　※エラー判定用、省略時はエラー判定なし
									//			（false指定と同じ）。ただし、
									//　　　　　　　　　primayKey, secondaryKey, indexes に
									//　　　　　　　　　指定された項目は必然的に入力必須となる。
				"min": 0,				//最小値　※エラー判定用、省略時はエラー判定なし。
				"max": 100			//最大値　※エラー判定用、省略時はエラー判定なし。
			},
			//メンバー定義:固定長配列の場合
			{
				"name": "tol",			//メンバー名
				"comment": "耐性",		//コメント
				"key": "param.tol",		//対象キー
				"type": "i8",			//データ型
				"isArray": true,			//配列か？　※規定値は false。
									//　　　　　　true 指定されたデータが、データ定義JSON上で
									//　　　　　　配列として定義されていなければエラー。その逆も同様。
				"arraySize": [ 10 ]		//配列の要素数　※配列の次元数分の要素数を指定。
									//　　　　　　　　二次元配列なら [ 5, 10 ] のように記述する。
									//　　　　　　　　JSONデータ上と要素数が一致しない場合はエラー。
			},
			//メンバー定義:不定長配列の場合
			{
				"name": "abilities",		//メンバー名
				"comment": "アビリティ",	//コメント
				"key": "abilities",		//対象キー
				"type": "u32",			//データ型
				"isVariableArray": true,	//不定長配列の指定　※isArray の指定を省略可。
				"arraySizeName": "abilitiesNum",
									//配列の要素数を記録するメンバー名
				"arraySizeType": "s8"	//配列の要素数を記録するメンバーのデータ型
									//　※省略時は s32とみなす
				//※不定長配列の場合、構造体にはポインターと要素数の二つのメンバーが定義される。
				//　通常、要素数のメンバーが先に、続いてポインターが並ぶ。
				//　　（例）s8 abilityNum;
				//　　　　　u32* abilities;
				//※実際のデータはバイナリデータの後部にまとめられ、ポインターはその位置を指す。
				//　バイナリデータ上では、データのオフセット値が記録される。
			},
			//メンバー:ネストした構造体の場合
			{
				"name": "param",		//メンバー名
				"comment": "パラメータ",	//コメント
				"key": "param",		//対象キー
				"type": "struct",		//データ型　※C言語の構造体をネストする場合は、
									//　　　　　　"struct" を指定して、データ型名に構造体名を指定。
				"typeName": "T_PARAM"	//データ型名
				//※実際の構造体は、"substructs" で定義する。
			},
		],
		
		"membersOrder":	//メンバーの並び順　※"members"の定義順と変えたい時だけ記述する。
					//　　　　　　　　　　これを指定する場合、"members"の全項目を指定しなければエラー。
					//　　　　　　　　　　"name" および "arraySizeName" を全て列挙する。
					//　　　　　　　　　　アラインメントを考慮した配置にしたい場合などに使用する。
		[
			"id",		//ID:crc
			"power",		//力:i8
			"abilitiesNum",	//アビリティ要素数:s8
			"tol",		//耐性:i8[10]
			"name",		//名前:str*
			"condition",	//有効化条件:T_EXPR*
			"abilities",	//アビリティ:u32*
			"param"		//パラメータ:T_PARAM
		]
	},
	
	"substructs":	//ネストした構造体
	[
		{
			"name": "T_PARAM",			//構造体名
			"comment": "パラメータ構造体",	//コメント
			
			"isMakeSource": true,			//構造体の定義をC言語ヘッダーに出力するか？
			"isInternalStructure": true,	//親の構造体の中にこの構造体を定義するかどうか？
			
			"members":	//メンバー
			[
				{
					"name": "atk",		//メンバー名
					"comment": "攻撃力",//コメント
					"key": "atk",		//対象キー　※JSONデータ上のキーだが、親キーは指定しない。
									//　　　　　　メンバー名と同じなら省略可能。
					"type": "i8"		//データ型
				},
				{
					"name": "def",		//メンバー名
					"comment": "守備力",//コメント
					"type": "i8"		//データ型
				},
				{
					"name": "special",		//メンバー名
					"comment": "特殊能力",	//コメント
					"type": "T_SPECIAL_PARAM",	//データ型
					"isVariableArray": true,	//不定長配列の指定
					"arraySizeName": "specialNum" //配列の要素数
				}
			],
			
			"membersOrder":	//メンバーの並び順
			[
				"atk",
				"def",
				"specialNum",
				"special"	
			]
		},
		{
			"name": "T_PARAM_DEEP",
			"comment": "特殊パラメータ構造体",//コメント
			
			"isMakeSource": false,		//構造体の定義をC言語ヘッダーに出力するか？
			
			"members":	//メンバー
			[
				{
					"name": "dark",	//メンバー名
					"comment": "闇",	//コメント
					"type": "i8"		//データ型
				},
				{
					"name": "shine",	//メンバー名
					"comment": "光",	//コメント
					"type": "i8"		//データ型
				}
			]
		}
	],
	
	//エラー判定用ルール　※メンバーごとの min, max, isReuired 以外のルールを設定したい場合に用いる。
	//　　　　　　　　　　※複数のルールを指定可。
	"rules":
	[
		{
			//ルール　※エラーメッセージ判定用のJavaScript処理を記述。
			//　　　　　エラーがある場合はエラーメッセージを return し、問題が無い場合は null を return。
			//　　　　※一つのオブジェクト（構造体）が取り込まれる毎に実行され、
			//　　　　　取り込んだオブジェクトは変数 obj として渡される。
			//　　　　※エラーメッセージ出力時は、データ定義位置の行番号と、主キーの情報もいっしょに出力される。
			"rule":
			" \
				var atk = obj.param.atk; \
				var def = obj.param.def; \
				if(atk < def) \
				{ \
					return \"ATK(\" + atk + \")は、DEF(\" + def + \") 以上の値にして下さい。\"; \
				} \
				return null; \
			"
		},
		{
			//ルール
			"rule":
			" \
				if(obj.tol[0] > 0 && obj.tol[1] > 0) \
				{ \
					return \"「耐性」は、どれか一つだけ入力して下さい。\"; \
				} \
				return null; \
			"
		}
	],
	
	"debugText":	//デバッグ用テキストテーブル　※実機上でCRC値をテキストに変換するためのテーブル作成用。
	[
		//対象メンバー, ファイル名プレイフィックス, ファイル名サフィックス, ファイル名拡張子
		//※指定メンバーの数値化（CRC化）した値と変換前のテキストのマップを出力。
		//※複数のキーをまとめて一つのファイルに記録可能。
		//※変換ツール実行時に指定された出力ファイル名を、指定に基づいて整形してファイル名にする。
		//※出力ファイルのフォルダは、変換ツール実行時に指定。
		{"keys": ["id", ""], "filePrefix": null, "fileSuffix": "_id", "fileExt": ".crc" },
		{"keys": "condition", "filePrefix": null, "fileSuffix": "_expr", "fileExt": ".crc" }
	]
}
