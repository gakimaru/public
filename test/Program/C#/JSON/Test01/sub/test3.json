//データフォーマット定義JSONサンプル
{
	"name": "CharaData",				//データフォーマット名　※構造一致照合用。
	"majorVer": 1,					//データフォーマットメジャーバージョン　※構造一致照合用。
	"minorVer": 0,					//データフォーマットマイナーバージョン　※構造一致照合用。
	"comment": "キャラパラメータ構造定義",	//コメント　※C言語ソース用。
	
	"headerFileName": "charaData.h",			//ソースファイル名　※C言語ヘッダーファイル出力用。
	"declFileName": "charaDataDecle.cpp",		//ソースファイル名　※C言語ソースファイル（バージョン整合用
									//　　　　　　　　　　構造定義）出力用。
	"isUsePragmaOnce": true,				//#pramgma once 使用指定　※C言語ヘッダーファイル出力用。
	"headerIncludeFiles": ["types.h"],		//インクルードファイル　※C言語ヘッダーファイルに適用。
									//　　　　　　　　　　　　複数指定可。
	"declIncludeFiles": ["gameDataDecl.h"],	//インクルードファイル　※C言語ソースファイル（バージョン整合用
									//　　　　　　　　　　　　構造定義）に適用。
									//　　　　　　　　　　　　複数指定可。
	"headerNamespace": ["charaDataDef"],		//ネームスペース　※C言語ヘッダーファイルに適用。
									//　　　　　　　　　ネストする場合は配列で複数指定。
	"declNamespace": ["charaDataDecl"],		//ネームスペース　※C言語ソースファイル（バージョン整合用
									//　　　　　　　　　構造定義）に適用。
									//　　　　　　　　　ネストする場合は配列で複数指定。
	"funcNameForGetDecl": "getGameDataDecl",	//バージョン整合用構造定義情報の取得関数名
									//　　　　　　　　※C言語ソースファイル（バージョン整合用
									//　　　　　　　　　構造定義）に適用。
	
	"mainStruct":	//構造体
	{
		"name": "T_CHARA",		//構造体名
		"comment": "キャラ構造体",	//コメント　※C言語ソース用。
		
		"isMakeSource": true,		//構造体の定義をC言語ヘッダーに出力するか？
							//　※規定値は true。汎用構造体などの定義済みの構造体を用いる場合は
							//　　 false を指定する。
		
		"primaryKey": "id",		//主キー項目　※メンバー名で指定。主キーの昇順にデータが並べ替えされる。
							//　　　　　　　重複検出でエラー。ネストした構造体のメンバーは指定不可。
		"secondaryKey": "name",	//副キー項目　※メンバー名で指定。検索用のインデックステーブルが作成される。
							//　　　　　　　重複検出でエラー。ネストした構造体のメンバーは指定不可。
		
		"indexes": ["kana"],		//インデックス項目　※キーで指定。並べ替え用のインデックステーブル作成用。
							//　　　　　　　　　　複数キー指定可。複合キー指定不可。重複検出なし。
							//　　　　　　　　　　ネストした構造体のメンバーは指定不可。
		
		"members":				//メンバー　※デフォルトでは、定義順がデータの並び順になるので注意。
		[
			//メンバー定義:基本形
			{
				"name": "id",			//メンバー名
				"comment": "識別ID",	//コメント　※C言語ソース用。
				"key": "id",			//対象キー　※JSONデータ上のキー。
									//　　　　　　省略時は "name" と同じとみなす。
				"type": "crc",			//データ型　※s8,u8,s16,u16,s32,u32,s64,u64,f31,f64,ptr,struct,
									//　　　　　　str,expr,crc,crcs を指定可。
									//　　　　　　crc,crcs は文字列が32bit整数に変換される。
									//　　　　　　expr は文字列がT_EXPR 型の計算式データに変換
									//　　　　　　される。
									//　　　　　　str と expr はポインターに変換され、バイナリ
									//　　　　　　データにはオフセット値として記録される。
				"typeName": "CRC32"		//データ型名　※C言語ソース用
									//　　　　　　　特別に指定したい場合だけ指定。
									//　　　　　　　通常は "type" に対応した型から自動判定される。
			},
			//メンバー定義:文字列型の場合
			{
				"name": "name",		//メンバー名
				"comment": "名前",		//コメント
				"type": "str"			//データ型　※文字列のデータ型は、C言語ソース上では
									//　　　　　　 const char* などのポインター型に置き換わる。
									//　　　　　　文字列データはバイナリデータの後部にまとめられ、
									//　　　　　　ポインターはその位置を指す。
									//　　　　　　バイナリデータ上では、文字列データのオフセット値が
									//　　　　　　記録される。
			},
			//メンバー定義:計算式型の場合
			{
				"name": "condition",		//メンバー名
				"comment": "有効化条件式",//コメント
				"type": "expr"			//データ型　※計算式のデータ型は、C言語ソース上では
									//　　　　　　 const T_EXPR* 型に置き換わる。
									//　　　　　　実際のデータはバイナリデータの後部にまとめられ、
									//　　　　　　ポインターはその位置を指す。
									//　　　　　　バイナリデータ上では、計算式データのオフセット値が
									//　　　　　　記録される。
									//　　　　　※JSONデータに記述された計算式（文字列）を解析して、
									//　　　　　　計算式データ（バイナリ）に変換して記録する。
									//　　　　　　この解析の際にエラー判定も行う。
									//　　　　　※計算式内で使用される関数は、予め用意された組み込み
									//　　　　　　関数（crcやpowなど）のほか、実機側の処理で
									//　　　　　　計算式用に用意された拡張関数（getChapterなどの
									//　　　　　　ゲーム依存の関数）を指定できる。
									//　　　　　　正しい名前とパラメータで拡張関数を使用しているか
									//　　　　　　どうかは、変換ツール実行時に渡される
									//　　　　　　「拡張関数定義リスト」に基づいて判定する。
			},
			//メンバー定義:値の場合　※エラー判定のサンプル
			{
				"name": "power",		//メンバー名
				"comment": "力",		//コメント
				"key": "param.power",	//対象キー　※JSONデータ上のネストしたデータは
									//　　　　　　「.」で区切って指定。
				"type": "i8",			//データ型
				"default": 1,			//省略時の規定値　※JSONデータ上で記述されなかった場合の規定値。
				"isRequired": false,		//入力必須項目？　※JSONデータ上で記述が必須か？
									//　　　　　　　　※エラー判定用、省略時はエラー判定なし
									//			（false指定と同じ）。ただし、
									//　　　　　　　　　primayKey, secondaryKey, indexes に
									//　　　　　　　　　指定された項目は必然的に入力必須となる。
				"min": 0,				//最小値　※エラー判定用、省略時はエラー判定なし。
				"max": 100				//最大値　※エラー判定用、省略時はエラー判定なし。
									//※データ型に応じた最小値～最大値の範囲チェックは
									//　デフォルトで行われる。例えば、i8 なら -128～127の
									//　範囲外の値が指定されたらエラー。
			},
			//メンバー定義:固定長配列の場合
			{
				"name": "tol",			//メンバー名
				"comment": "耐性",		//コメント
				"key": "param.tol",		//対象キー
				"type": "f32",			//データ型
				"isArray": true,			//配列か？　※規定値は false。
									//　　　　　　true 指定されたデータが、データ定義JSON上で
									//　　　　　　配列として定義されていなければエラー。その逆も同様。
				"arraySize": [ 10 ]		//配列の要素数　※配列の次元数分の要素数を指定。
									//　　　　　　　　二次元配列なら [ 5, 10 ] のように記述する。
									//　　　　　　　　JSONデータ上と要素数が一致しない場合はエラー。
			},
			//メンバー定義:不定長配列の場合
			{
				"name": "abilities",		//メンバー名
				"comment": "アビリティ",	//コメント
				"key": "abilities",		//対象キー
				"type": "u32",			//データ型
				"isVariableArray": true,	//不定長配列の指定　※isArray の指定を省略可。
				"arraySizeName": "abilitiesNum",
									//配列の要素数を記録するメンバー名
				"arraySizeType": "i8"	//配列の要素数を記録するメンバーのデータ型
									//　※省略時は i32とみなす
				//※不定長配列の場合、構造体にはポインターと要素数の二つのメンバーが定義される。
				//　通常、要素数のメンバーが先に、続いてポインターが並ぶ。
				//　　（例）i8 abilityNum;
				//　　　　　u32* abilities;
				//※実際のデータはバイナリデータの後部にまとめられ、ポインターはその位置を指す。
				//　バイナリデータ上では、データのオフセット値が記録される。
			},
			//メンバー:ネストした構造体の場合
			{
				"name": "param",		//メンバー名
				"comment": "パラメータ",	//コメント
				"key": "param",		//対象キー
				"type": "struct",		//データ型　※C言語の構造体をネストする場合は、
									//　　　　　　"struct" を指定して、データ型名に構造体名を指定。
				"typeName": "T_PARAM"	//データ型名
				//※実際の構造体は、"substructs" で定義する。
			},
			//メンバー定義:固定値の場合
			{
				"name": "fixed",	//メンバー名
				"comment": "固定値",	//コメント
				"key": null,		//対象キー　※対象キーに null を指定することで、JSONデータ側に
								//　　　　　　存在しないメンバーを定義することが可能。
				"type": "i16",		//データ型
				"default": 1,		//省略時の規定値　※固定値の指定に使用
			},
		],
		
		"membersOrder":	//メンバーの並び順　※"members"の定義順と変えたい時だけ記述する。
					//　　　　　　　　　　これを指定する場合、"members"の全項目を指定しなければエラー。
					//　　　　　　　　　　"name" および "arraySizeName" を全て列挙する。
					//　　　　　　　　　　アラインメントを考慮した配置にしたい場合などに使用する。
		[
			"id",		//ID:crc
			"power",		//力:i8
			"abilitiesNum",	//アビリティ(Num):i8
			"fixed",		//固定値:i16
			"tol",		//耐性:f32[10]
			"name",		//名前:str*
			"condition",	//有効化条件:T_EXPR*
			"abilities",	//アビリティ:u32*
			"param"		//パラメータ:T_PARAM
		]
	},
	
	"subStructs":	//ネストした構造体　※「struct」とほどぼ同様の構造だが、配列で複数の構造体を定義する。
	[
		{
			"name": "T_PARAM",			//構造体名
			"comment": "パラメータ構造体",	//コメント
			
			"isMakeSource": true,			//構造体の定義をC言語ヘッダーに出力するか？
			"isInternalStructure": true,	//親の構造体の中にこの構造体を定義するかどうか？
			
			"members":	//メンバー
			[
				{
					"name": "atk",		//メンバー名
					"comment": "攻撃力",//コメント
					"key": "atk",		//対象キー　※JSONデータ上のネストしたデータのキーだが、
									//　　　　　　親キーは指定しない。
									//　　　　　※メンバー名と同じなら省略可能。
					"type": "i16"		//データ型
				},
				{
					"name": "def",		//メンバー名
					"comment": "守備力",//コメント
					"type": "i16"		//データ型
				},
				{
					"name": "specials",		//メンバー名
					"comment": "特殊能力",	//コメント
					"type": "struct",		//データ型　※さらにネストした構造体も指定可能
					"typeName": "T_SPECIAL_PARAM",	//データ型名
					"isVariableArray": true,	//不定長配列の指定
					"arraySizeName": "specialsNum" //配列の要素数
				}
			],
		
			"membersOrder":	//メンバーの並び順
			[
				"atk",		//攻撃力:i16
				"def",		//防御力:i16
				"specialNum",	//特殊能力(Num):s32
				"special"		//特殊能力:T_SPECIAL_PARAM*
			]
		},
		{
			"name": "T_SPECIAL_PARAM",
			"comment": "特殊パラメータ構造体",//コメント
			
			"isMakeSource": true,		//構造体の定義をC言語ヘッダーに出力するか？
			"isInternalStructure": false,	//親の構造体の中にこの構造体を定義するかどうか？
			
			"members":	//メンバー
			[
				{
					"name": "dark",	//メンバー名
					"comment": "闇",	//コメント
					"type": "u32"		//データ型
				},
				{
					"name": "shine",	//メンバー名
					"comment": "光",	//コメント
					"type": "u32"		//データ型
				}
			]
		}
	],
	
	//【要調査】できれば対応
	//エラー判定用ルール　※メンバーごとの min, max, isReuired 以外のルールを設定したい場合に用いる。
	//　　　　　　　　　　※複数のルールを指定可。
	//　　　　　　　　　　※メンバーの値を計算結果などで書き換えたい場合にも利用可能。
	"rules":
	[
		{
			//ルール　※エラーメッセージ判定用のJavaScript処理を記述。一塊の文字列として定義する。
			//　　　　　エラーがある場合はエラーメッセージを return し、問題が無い場合は obj を return。
			//　　　　※一つのオブジェクト（構造体）が取り込まれる毎に実行され、
			//　　　　　取り込んだオブジェクトは変数 obj として渡される。
			//　　　　　なお、この時の obj は、strや可変長配列などの情報はポインター化（オフセット化）
			//　　　　　されていないため、そのままメンバーにアクセスできる。crcなどの組み込み関数、
			//　　　　　exprによる計算式解析もまだ行われていない状態。ルールを一通りパスした後に
			//　　　　　それらの処理を行う。
			//　　　　※エラーメッセージ出力時は、データ定義位置の行番号と、主キーの情報もいっしょに出力される。
			//　　　　※obj のメンバーに値を代入して返すことも可能。
			"rule":
			" \
				var atk = obj.param.atk; \
				var def = obj.param.def; \
				if(atk < def) \
				{ \
					return \"ATK(\" + atk + \")は、DEF(\" + def + \") 以上の値にして下さい。\"; \
				} \
				obj.tol[2] = obj.tol[0] + obj.tol[1]; /*値を書き換え可能*/ \
				return null; \
			"
		},
		{
			//ルール
			"rule":
			" \
				if(obj.tol[0] > 0 && obj.tol[1] > 0) \
				{ \
					return \"「耐性」は、どれか一つだけ入力して下さい。\"; \
				} \
				return null; \
			"
		}
	],
}
